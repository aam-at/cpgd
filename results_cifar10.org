#+options: tex:verbatim
#+TITLE: Results on cifar10 dataset

* General
#+NAME: init_block
#+BEGIN_SRC python
  import numpy as np
  import pandas as pd
  from pathlib import Path
  import re
  import glob

  from lib.parse_logs import parse_test_optimizer_log, org_group_and_summarize, org_table


  def get_unique_name(name):
      try:
          unique_name = re.findall(".+(?=_.+)", name)[0]
      except:
          unique_name = re.findall(".+(?=\d+)", name)[0]
      parts = name.split("_")
      unique_name = "_".join(parts[4:13])
      return unique_name


  def parse_output_logs(paths, norm, type, allowed_thresholds=None):
      if not isinstance(paths, (list, tuple)):
          paths = list(paths)
      if allowed_thresholds is None:
          allowed_thresholds = []

      df_sublist = []
      for p in paths:
          p = Path(p)
          df = parse_test_optimizer_log(p / f"test_{type}_{norm}" / "cifar10",
                                        exclude=['nll_loss', 'conf'])
          df_sublist.append(df)
      df = pd.concat(df_sublist, ignore_index=True)
      if len(allowed_thresholds) > 0:
          for col in df.columns:
              if col.startswith(f"acc_{norm}_"):
                  if col not in [
                          f"acc_{norm}_{th:.3f}" for th in allowed_thresholds
                  ]:
                      df = df.drop(columns=[col])
      df = df.sort_values(norm, ascending=True)
      return df


  def output_org_results(logs, norm, summarize=False, topk=100):
      if summarize:
          logs = pd.concat(logs, ignore_index=True)
          logs_org = org_group_and_summarize(logs,
                                             group_by=get_unique_name,
                                             sort_groups=True,
                                             sort_keys=norm)
      else:
          logs_org = []
          first = True
          for log in logs:
              if first:
                  if topk is not None:
                      logs_org.extend(org_table(log)[:3 + topk] + [None])
                  else:
                      logs_org.extend(org_table(log))
                      first = False
              else:
                  if topk is not None:
                      logs_org.extend(org_table(log)[3:topk + 3] + [None])
                  else:
                      logs_org.extend(org_table(log)[3:])
      return logs_org
#+END_SRC

#+RESULTS: init_block
: None

#+NAME: output_results
#+BEGIN_SRC python :noweb yes
  dirs = glob.glob("./results/cifar10*")
  df = parse_output_logs(dirs, norm, type, allowed_thresholds=thresholds)
  df = df[getattr(df, f"acc_{norm}") == 0]
  df_org = output_org_results([df], norm, summarize=False, topk=100)
#+END_SRC

#+RESULTS: output_results

* All
#+BEGIN_SRC python :noweb yes :results value :return df_org
  <<init_block>>
  logs = []
  for norm, type in itertools.product(['l0', 'l1', 'l2', 'li'], ['plain', 'linf', 'l2']):
      if norm != 'l1':
          continue
      df = parse_output_logs(["./results/cifar10_6"],
                          norm,
                          type,
                          allowed_thresholds=None)
      df = df[getattr(df, f"acc_{norm}") == 0]
      df = df[getattr(df, f"conf_{norm}") > 0]
      df = df[df.name.str.contains("100_10k")]
      df['lp'] = df[norm]
      logs.append(df)
  df_org = output_org_results(logs, 'lp', summarize=True)
#+END_SRC

#+RESULTS:

* L0
** Plain
#+BEGIN_SRC python :noweb yes :var norm="l0" :var type="plain" :results value :return df_org
  <<init_block>>
  thresholds = [5, 8, 10, 15]
  <<output_results>>
#+END_SRC

#+RESULTS:

** Linf
#+BEGIN_SRC python :noweb yes :var norm="l0" :var type="linf" :results value :return df_org
  <<init_block>>
  thresholds = np.linspace(2, 10, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

** L2
#+BEGIN_SRC python :noweb yes :var norm="l0" :var type="l2" :results value :return df_org
  <<init_block>>
  thresholds = np.linspace(5, 45, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

* L1
** Plain
#+BEGIN_SRC python :noweb yes :var norm="l1" :var type="plain" :results value :return df_org
  <<init_block>>
  thresholds = np.linspace(2, 10, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

** Linf
#+BEGIN_SRC python :noweb yes :var norm="l1" :var type="linf" :results value :return df_org
  <<init_block>>
  thresholds = np.linspace(2.5, 12.5, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

** L2
#+BEGIN_SRC python :noweb yes :var norm="l1" :var type="l2" :results value :return df_org
  <<init_block>>
  thresholds = np.linspace(5, 20, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

* L2
** Plain
#+BEGIN_SRC python :noweb yes :var norm="l2" :var type="plain" :results value :return df_org
  <<init_block>>
  thresholds = [0.1, 0.15, 0.2, 0.3, 0.4]
  <<output_results>>
#+END_SRC

#+RESULTS:

** Linf
#+BEGIN_SRC python :noweb yes :var norm="l2" :var type="linf" :results value :return df_org
  <<init_block>>
  thresholds = np.linspace(1.0, 3.0, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

** L2
#+BEGIN_SRC python :noweb yes :var norm="l2" :var type="l2" :results value :return df_org
  <<init_block>>
  thresholds = np.linspace(1.0, 3.0, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

* Linf
** Plain
#+BEGIN_SRC python :noweb yes :var norm="li" :var type="plain" :results value :return df_org
  <<init_block>>
  thresholds = [1.0] #np.linspace(0.03, 0.11, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

** Linf
#+BEGIN_SRC python :noweb yes :var norm="li" :var type="linf" :results value :return df_org
  <<init_block>>
  thresholds = [1.0] #np.round(np.linspace(2, 10, 5) / 255, 3)
  <<output_results>>
#+END_SRC

#+RESULTS:

** L2
#+BEGIN_SRC python :noweb yes :var norm="li" :var type="l2" :results value :return df_org
  <<init_block>>
  thresholds = np.linspace(0.05, 0.25, 5)
  <<output_results>>
#+END_SRC

#+RESULTS:

* COMMENT Local Variables
# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
